<!DOCTYPE html>
<html>
<head>
<title>Pure Pursuit Simulator with Robust U-Turn Handling</title>
<style>
  body { margin: 0; display: flex; height: 100vh; font-family: monospace; }
  #canvas-container { flex: 1; position: relative; min-height: 400px; }
  canvas { display: block; width: 100%; height: 100%; }
  #log-table-container {
    width: 350px;
    overflow-y: auto;
    border-left: 2px solid #333;
  }
  table { width: 100%; border-collapse: collapse; font-size: 12px; }
  th, td { border: 1px solid #999; padding: 2px 4px; text-align: right; }
  th { background: #ddd; position: sticky; top: 0; }
  #stopBtn {
    position: fixed;
    top: 10px;
    left: 10px;
    z-index: 10;
    padding: 8px 12px;
    font-weight: bold;
  }
</style>
</head>
<body>

<button id="stopBtn">Stop</button>

<div id="canvas-container">
  <canvas id="simulatorCanvas"></canvas>
</div>

<div id="log-table-container">
  <table id="logTable">
    <thead>
      <tr>
        <th>Frame</th><th>X</th><th>Y</th><th>Î˜</th>
        <th>LX</th><th>LY</th><th>Dist</th><th>Curv</th>
        <th>Left</th><th>Right</th><th>PathIdx</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<script>
/* Robot Parameters */
const wheelTrack = 30;
const robotRadius = 10;
const lookaheadDistance = 25;
const targetVelocity = 5; // slow motion
const speedFactor = 0.35;

/* Robot State */
let robotX = 50, robotY = 50, robotTheta = 0;
let currentPathIndex = 0;
let frameCount = 0;
let running = true;

/* U-Turn State */
let reversing = false;
let reverseTarget = null;
let reverseAxis = null;

/* Path */
const path = [
  [50,50],[50,100],[50,150],[100,150],[50,150],[50,200],[100,200],
  [150,200],[150,150],[200,150],[200,200],[200,250],[250,250],
  [250,200],[300,200],[300,150],[300,100],[300,150],[250,150],
  [250,100],[250,50],[200,50]
];

/* Detect U-turns */
const uTurnSegments = [];
for (let i = 0; i < path.length - 2; i++) {
  if (path[i][0] === path[i+2][0] && path[i][1] === path[i+2][1]) {
    uTurnSegments.push({ start: i+1, end: i+2 });
  }
}

/* Utilities */
function toRad(d){return d*Math.PI/180;}
function toDeg(r){return r*180/Math.PI;}
function getDistance(x1,y1,x2,y2){return Math.hypot(x2-x1,y2-y1);}

/* Pure Pursuit */
function getLookaheadPoint(startIndex){
  for(let i=startIndex;i<path.length-1;i++){
    const [x1,y1] = path[i], [x2,y2] = path[i+1];
    const dx=x2-x1, dy=y2-y1;
    const fx=x1-robotX, fy=y1-robotY;
    const a=dx*dx+dy*dy, b=2*(fx*dx+fy*dy), c=fx*fx+fy*fy-lookaheadDistance*lookaheadDistance;
    const disc=b*b-4*a*c;
    if(disc<0) continue;
    const sqrtDisc=Math.sqrt(disc);
    const t1=(-b+sqrtDisc)/(2*a), t2=(-b-sqrtDisc)/(2*a);
    for(const t of [t1,t2]) if(t>=0&&t<=1) return [x1+t*dx,y1+t*dy];
  }
  return path[path.length-1];
}

function calculateCurvature(point){
  const dx=point[0]-robotX, dy=point[1]-robotY, dist=Math.hypot(dx,dy);
  if(dist<1) return 0;
  let angleDiff=Math.atan2(dy,dx)-toRad(robotTheta);
  while(angleDiff>Math.PI) angleDiff-=2*Math.PI;
  while(angleDiff<=-Math.PI) angleDiff+=2*Math.PI;
  return 2*Math.sin(angleDiff)/dist;
}

function calculateWheelSpeeds(curvature){
  return [
    targetVelocity*(1-curvature*wheelTrack/2)*speedFactor,
    targetVelocity*(1+curvature*wheelTrack/2)*speedFactor
  ];
}

function updateOdometry(left,right){
  const d=(left+right)/2, dTheta=(right-left)/wheelTrack;
  robotTheta+=toDeg(dTheta);
  robotX+=d*Math.cos(toRad(robotTheta));
  robotY+=d*Math.sin(toRad(robotTheta));
}

/* Canvas */
const canvas=document.getElementById("simulatorCanvas"), ctx=canvas.getContext("2d");
function drawPath(){ctx.strokeStyle="blue";ctx.lineWidth=2;ctx.beginPath();path.forEach((p,i)=>i===0?ctx.moveTo(p[0],p[1]):ctx.lineTo(p[0],p[1]));ctx.stroke();}
function drawRobot(){ctx.fillStyle="red";ctx.beginPath();ctx.arc(robotX,robotY,robotRadius,0,2*Math.PI);ctx.fill();const a=toRad(robotTheta);ctx.strokeStyle="black";ctx.beginPath();ctx.moveTo(robotX,robotY);ctx.lineTo(robotX+robotRadius*Math.cos(a),robotY+robotRadius*Math.sin(a));ctx.stroke();}
function drawLookahead(point){ctx.fillStyle="green";ctx.beginPath();ctx.arc(point[0],point[1],5,0,2*Math.PI);ctx.fill();}

/* Table Logging */
const logTableBody=document.querySelector("#logTable tbody");
function logFrameData(frame,lx,ly,dist,curvature,left,right){
  const row=document.createElement("tr");
  row.innerHTML=`<td>${frame}</td><td>${robotX.toFixed(1)}</td><td>${robotY.toFixed(1)}</td><td>${robotTheta.toFixed(1)}</td><td>${lx.toFixed(1)}</td><td>${ly.toFixed(1)}</td><td>${dist.toFixed(1)}</td><td>${curvature.toFixed(3)}</td><td>${left.toFixed(1)}</td><td>${right.toFixed(1)}</td><td>${currentPathIndex}</td>`;
  logTableBody.appendChild(row);
  logTableBody.scrollTop=logTableBody.scrollHeight;
}

/* Stop Button */
const stopBtn=document.getElementById("stopBtn");
stopBtn.addEventListener("click",()=>{running=!running;stopBtn.textContent=running?"Stop":"Resume";});

/* Main Loop */
function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawPath();

  if(currentPathIndex<path.length-1 && running){
    if(reversing){
      // Move exactly along reverse axis
      if(reverseAxis==="x"){
        const dx=reverseTarget[0]-robotX;
        robotX += Math.sign(dx)*targetVelocity*speedFactor;
        if(Math.abs(dx)<targetVelocity*speedFactor) reversing=false;
      } else {
        const dy=reverseTarget[1]-robotY;
        robotY += Math.sign(dy)*targetVelocity*speedFactor;
        if(Math.abs(dy)<targetVelocity*speedFactor) reversing=false;
      }
      const distToTarget = getDistance(robotX,robotY,reverseTarget[0],reverseTarget[1]);
      logFrameData(frameCount++, reverseTarget[0], reverseTarget[1], distToTarget, 0, 0, 0);

      if(!reversing) currentPathIndex++;

    } else {
      const uTurn = uTurnSegments.find(seg=>currentPathIndex===seg.start);
      if(uTurn){
        reversing=true;
        reverseTarget=path[uTurn.end];
        reverseAxis = Math.abs(path[uTurn.start][0]-reverseTarget[0])<1?"y":"x";
      } else {
        const lookahead=getLookaheadPoint(currentPathIndex);
        const distToLookahead=getDistance(robotX,robotY,lookahead[0],lookahead[1]);
        const curvature=calculateCurvature(lookahead);
        const [left,right]=calculateWheelSpeeds(curvature);
        updateOdometry(left,right);
        drawLookahead(lookahead);
        logFrameData(frameCount++, lookahead[0], lookahead[1], distToLookahead, curvature, left, right);
        if(getDistance(robotX,robotY,path[currentPathIndex+1][0],path[currentPathIndex+1][1])<lookaheadDistance/2){
          currentPathIndex++;
        }
      }
    }
  }

  drawRobot();
  requestAnimationFrame(loop);
}

/* Resize */
function resize(){canvas.width=canvas.parentElement.clientWidth;canvas.height=canvas.parentElement.clientHeight;}
window.addEventListener("resize",resize);resize();loop();
</script>

</body>
</html>
