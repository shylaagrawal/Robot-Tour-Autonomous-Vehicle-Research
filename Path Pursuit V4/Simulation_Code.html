<!DOCTYPE html>
<html>
<head>
<title>Pure Pursuit Simulator with U-Turn Handling</title>
<style>
  body { margin: 0; display: flex; height: 100vh; font-family: monospace; }
  #canvas-container { flex: 1; position: relative; min-height: 400px; }
  canvas { display: block; width: 100%; height: 100%; }
  #log-table-container {
    width: 360px;
    overflow-y: auto;
    border-left: 2px solid #333;
  }
  table { width: 100%; border-collapse: collapse; font-size: 12px; }
  th, td { border: 1px solid #999; padding: 2px 4px; text-align: right; }
  th { background: #ddd; position: sticky; top: 0; }
  #stopBtn {
    position: fixed;
    top: 10px;
    left: 10px;
    z-index: 10;
    padding: 8px 12px;
    font-weight: bold;
  }
</style>
</head>
<body>

<button id="stopBtn">Stop</button>

<div id="canvas-container">
  <canvas id="simulatorCanvas"></canvas>
</div>

<div id="log-table-container">
  <table id="logTable">
    <thead>
      <tr>
        <th>Frame</th><th>X</th><th>Y</th><th>Θ</th>
        <th>TX</th><th>TY</th><th>Δ</th>
        <th>L</th><th>R</th><th>Idx</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<script>
/* Robot parameters */
const wheelTrack = 30;
const robotRadius = 10;

/* Slow motion */
const lookaheadDistance = 25;
const targetVelocity = 5;
const speedFactor = 0.35;

/* Robot state */
let robotX = 50;
let robotY = 50;
let robotTheta = 0;
let currentPathIndex = 0;
let frameCount = 0;
let running = true;

/* U-turn state */
let reversing = false;
let reverseTarget = null;

/* Path */
const path = [
  [50,50],[50,100],[50,150],[100,150],[50,150],[50,200],[100,200],
  [150,200],[150,150],[200,150],[200,200],[200,250],[250,250],
  [250,200],[300,200],[300,150],[300,100],[300,150],[250,150],
  [250,100],[250,50],[200,50]
];

/* Detect U-turns */
const uTurnSegments = [];
for (let i = 0; i < path.length - 2; i++) {
  if (path[i][0] === path[i+2][0] && path[i][1] === path[i+2][1]) {
    uTurnSegments.push({ start: i+1, end: i+2 });
  }
}

/* Helpers */
const toRad = d => d * Math.PI / 180;
const toDeg = r => r * 180 / Math.PI;
const dist = (x1,y1,x2,y2) => Math.hypot(x2-x1,y2-y1);

/* Pure Pursuit */
function getLookaheadPoint(startIdx){
  for(let i=startIdx;i<path.length-1;i++){
    const [x1,y1] = path[i];
    const [x2,y2] = path[i+1];
    const dx=x2-x1, dy=y2-y1;
    const fx=x1-robotX, fy=y1-robotY;

    const a=dx*dx+dy*dy;
    const b=2*(fx*dx+fy*dy);
    const c=fx*fx+fy*fy-lookaheadDistance*lookaheadDistance;
    const disc=b*b-4*a*c;
    if(disc<0) continue;

    const t=(-b+Math.sqrt(disc))/(2*a);
    if(t>=0 && t<=1) return [x1+t*dx,y1+t*dy];
  }
  return path[path.length-1];
}

function curvature(pt){
  const dx=pt[0]-robotX, dy=pt[1]-robotY;
  const d=Math.hypot(dx,dy);
  if(d<1) return 0;
  const a=Math.atan2(dy,dx)-toRad(robotTheta);
  return 2*Math.sin(a)/d;
}

function wheelSpeeds(k){
  return [
    targetVelocity*(1-k*wheelTrack/2)*speedFactor,
    targetVelocity*(1+k*wheelTrack/2)*speedFactor
  ];
}

function odometry(l,r){
  const d=(l+r)/2;
  const dTheta=(r-l)/wheelTrack;
  robotTheta+=toDeg(dTheta);
  robotX+=d*Math.cos(toRad(robotTheta));
  robotY+=d*Math.sin(toRad(robotTheta));
}

/* Canvas */
const canvas=document.getElementById("simulatorCanvas");
const ctx=canvas.getContext("2d");

function drawPath(){
  ctx.strokeStyle="blue";
  ctx.lineWidth=2;
  ctx.beginPath();
  path.forEach((p,i)=>i?ctx.lineTo(p[0],p[1]):ctx.moveTo(p[0],p[1]));
  ctx.stroke();
}

function drawRobot(){
  ctx.fillStyle="red";
  ctx.beginPath();
  ctx.arc(robotX,robotY,robotRadius,0,2*Math.PI);
  ctx.fill();

  const a=toRad(robotTheta);
  ctx.strokeStyle="black";
  ctx.beginPath();
  ctx.moveTo(robotX,robotY);
  ctx.lineTo(robotX+robotRadius*Math.cos(a),robotY+robotRadius*Math.sin(a));
  ctx.stroke();
}

/* Logging */
const logBody=document.querySelector("#logTable tbody");
function log(tx,ty,delta,l,r){
  const row=document.createElement("tr");
  row.innerHTML=`
    <td>${frameCount++}</td>
    <td>${robotX.toFixed(1)}</td>
    <td>${robotY.toFixed(1)}</td>
    <td>${robotTheta.toFixed(1)}</td>
    <td>${tx.toFixed(1)}</td>
    <td>${ty.toFixed(1)}</td>
    <td>${delta.toFixed(1)}</td>
    <td>${l.toFixed(2)}</td>
    <td>${r.toFixed(2)}</td>
    <td>${currentPathIndex}</td>`;
  logBody.appendChild(row);
  logBody.scrollTop=logBody.scrollHeight;
}

/* Stop */
stopBtn.onclick=()=>running=!running;

/* Main loop */
function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawPath();

  if(running && currentPathIndex < path.length-1){

    if(reversing){
      const tx = reverseTarget[0];
      const ty = reverseTarget[1];

      const dx = Math.abs(robotX - tx);
      const dy = Math.abs(robotY - ty);

      if(dx > 1 && dy > 1){
        const step = targetVelocity * speedFactor;
        robotX -= step * Math.cos(toRad(robotTheta));
        robotY -= step * Math.sin(toRad(robotTheta));
        log(tx, ty, Math.min(dx,dy), -step, -step);
      } else {
        reversing = false;
        currentPathIndex++;
      }

    } else {
      const uTurn = uTurnSegments.find(s => s.start === currentPathIndex);
      if(uTurn){
        reverseTarget = path[uTurn.end];
        reversing = true;
      } else {
        const la = getLookaheadPoint(currentPathIndex);
        const d = dist(robotX,robotY,la[0],la[1]);
        const k = curvature(la);
        const [l,r] = wheelSpeeds(k);
        log(la[0],la[1],d,l,r);
        odometry(l,r);

        if(dist(robotX,robotY,
                path[currentPathIndex+1][0],
                path[currentPathIndex+1][1]) < lookaheadDistance/2){
          currentPathIndex++;
        }
      }
    }
  }

  drawRobot();
  requestAnimationFrame(loop);
}

/* Resize */
function resize(){
  canvas.width=canvas.parentElement.clientWidth;
  canvas.height=canvas.parentElement.clientHeight;
}
window.onresize=resize;
resize();
loop();
</script>

</body>
</html>
