<!DOCTYPE html>
<html>
<head>
<title>Pure Pursuit Simulator with Instrumentation</title>
<style>
  body { margin: 0; display: flex; height: 100vh; font-family: monospace; }
  #canvas-container { flex: 1; position: relative; min-height: 400px; }
  canvas { display: block; width: 100%; height: 100%; }
  #log-table-container {
    width: 350px;
    overflow-y: auto;
    border-left: 2px solid #333;
  }
  table { width: 100%; border-collapse: collapse; font-size: 12px; }
  th, td { border: 1px solid #999; padding: 2px 4px; text-align: right; }
  th { background: #ddd; position: sticky; top: 0; }
</style>
</head>
<body>

<div id="canvas-container">
  <canvas id="simulatorCanvas"></canvas>
</div>
<div id="log-table-container">
  <table id="logTable">
    <thead>
      <tr>
        <th>Frame</th><th>X</th><th>Y</th><th>Î˜</th>
        <th>LX</th><th>LY</th><th>Dist</th><th>Curv</th>
        <th>Left</th><th>Right</th><th>PathIdx</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<script>
/* ================================
   Constants and Robot Parameters
================================ */
const wheelTrack = 30;           // pixels
const robotRadius = 10;
const lookaheadDistance = 20;
const targetVelocity = 15;
const speedFactor = 0.5;

/* ================================
   Robot State
================================ */
let robotX = 50;
let robotY = 50;
let robotTheta = 0; // degrees
let currentPathIndex = 0;
let frameCount = 0;

/* ================================
   Path
================================ */
const path = [
  [50, 50],[200, 50],[200, 150], [200,200], [150,200], [50, 200], [50, 150], [50,50]
];

/* ================================
   Math Utilities
================================ */
function toRadians(deg) { return deg * Math.PI / 180; }
function toDegrees(rad) { return rad * 180 / Math.PI; }
function getDistance(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }

/* ================================
   Pure Pursuit Functions
================================ */
function getLookaheadPoint(path, lookahead, startIndex) {
  for (let i = startIndex; i < path.length - 1; i++) {
    const p1 = path[i];
    const p2 = path[i + 1];
    const dx = p2[0] - p1[0];
    const dy = p2[1] - p1[1];
    const fx = p1[0] - robotX;
    const fy = p1[1] - robotY;
    const a = dx*dx + dy*dy;
    const b = 2*(fx*dx + fy*dy);
    const c = fx*fx + fy*fy - lookahead*lookahead;
    const disc = b*b - 4*a*c;
    if (disc < 0) continue;
    const sqrtDisc = Math.sqrt(disc);
    const t1 = (-b + sqrtDisc)/(2*a);
    const t2 = (-b - sqrtDisc)/(2*a);
    for (const t of [t1, t2]) {
      if (t >= 0 && t <= 1) {
        return [p1[0] + t*dx, p1[1] + t*dy];
      }
    }
  }
  return path[path.length - 1];
}

function calculateCurvature(lookaheadPoint) {
  const dx = lookaheadPoint[0] - robotX;
  const dy = lookaheadPoint[1] - robotY;
  const dist = Math.hypot(dx, dy);
  if (dist < 1) return 0;
  const angleToTarget = Math.atan2(dy, dx);
  const robotAngle = toRadians(robotTheta);
  let angleDiff = angleToTarget - robotAngle;
  while (angleDiff > Math.PI) angleDiff -= 2*Math.PI;
  while (angleDiff <= -Math.PI) angleDiff += 2*Math.PI;
  return (2*Math.sin(angleDiff))/dist;
}

function calculateWheelSpeeds(curvature) {
  let left = targetVelocity*(1 - curvature*wheelTrack/2);
  let right = targetVelocity*(1 + curvature*wheelTrack/2);
  return [left*speedFactor, right*speedFactor];
}

function updateOdometry(leftSpeed, rightSpeed) {
  const dl = leftSpeed;
  const dr = rightSpeed;
  const d = (dl + dr)/2;
  const dTheta = (dr - dl)/wheelTrack;
  robotTheta += toDegrees(dTheta);
  robotX += d * Math.cos(toRadians(robotTheta));
  robotY += d * Math.sin(toRadians(robotTheta));
}

/* ================================
   Canvas Rendering
================================ */
const canvas = document.getElementById("simulatorCanvas");
const ctx = canvas.getContext("2d");

function drawPath() {
  ctx.strokeStyle = "blue";
  ctx.lineWidth = 2;
  ctx.beginPath();
  path.forEach((p,i) => i===0?ctx.moveTo(p[0],p[1]):ctx.lineTo(p[0],p[1]));
  ctx.stroke();
}

function drawRobot() {
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(robotX, robotY, robotRadius, 0, 2*Math.PI);
  ctx.fill();
  const angle = toRadians(robotTheta);
  ctx.strokeStyle = "black";
  ctx.beginPath();
  ctx.moveTo(robotX, robotY);
  ctx.lineTo(robotX + robotRadius*Math.cos(angle), robotY + robotRadius*Math.sin(angle));
  ctx.stroke();
}

function drawLookahead(point) {
  ctx.fillStyle = "green";
  ctx.beginPath();
  ctx.arc(point[0], point[1], 5, 0, 2*Math.PI);
  ctx.fill();
}

/* ================================
   Instrumentation Table
================================ */
const logTableBody = document.querySelector("#logTable tbody");
function logFrameData(frame, lx, ly, dist, curvature, left, right) {
  const row = document.createElement("tr");
  row.innerHTML = `
    <td>${frame}</td>
    <td>${robotX.toFixed(1)}</td>
    <td>${robotY.toFixed(1)}</td>
    <td>${robotTheta.toFixed(1)}</td>
    <td>${lx.toFixed(1)}</td>
    <td>${ly.toFixed(1)}</td>
    <td>${dist.toFixed(1)}</td>
    <td>${curvature.toFixed(3)}</td>
    <td>${left.toFixed(1)}</td>
    <td>${right.toFixed(1)}</td>
    <td>${currentPathIndex}</td>
  `;
  logTableBody.appendChild(row);
  logTableBody.scrollTop = logTableBody.scrollHeight;
}

/* ================================
   Main Loop
================================ */
function loop() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawPath();

  if (currentPathIndex < path.length - 1) {
    const lookahead = getLookaheadPoint(path, lookaheadDistance, currentPathIndex);
    const dist = getDistance(robotX, robotY, lookahead[0], lookahead[1]);
    const curvature = calculateCurvature(lookahead);
    const [left, right] = calculateWheelSpeeds(curvature);

    logFrameData(frameCount++, lookahead[0], lookahead[1], dist, curvature, left, right);

    updateOdometry(left, right);
    drawLookahead(lookahead);

    if (getDistance(robotX, robotY,
        path[currentPathIndex + 1][0],
        path[currentPathIndex + 1][1]) < lookaheadDistance/2) {
      currentPathIndex++;
    }
  }

  drawRobot();
  requestAnimationFrame(loop);
}

function resize() {
  canvas.width = canvas.parentElement.clientWidth;
  canvas.height = canvas.parentElement.clientHeight;
}

window.addEventListener("resize", resize);
resize();
loop();
</script>

</body>
</html>
